# 간단한 소켓 통신 Mock

## 개요
이 프로젝트는 자바에서 단일 스레드로 서버와 클라이언트가 한 번의 메시지 교환을 수행하는 예시 코드입니다. 서버는 클라이언트로부터 메시지를 수신한 뒤, 사용자의 콘솔 입력을 받아 클라이언트에게 답장을 보내도록 구현되어 있습니다.

## 프로젝트 구조
```
simpleSocket/
├── ClientMock.java      # 클라이언트 구현
├── ServerMock.java      # 서버 구현
├── SimpleSocketTest.java # 서버와 클라이언트를 실행하는 테스트 클래스
```

## 특징
- **단일 스레드 구현**: 메인 흐름(단일 스레드)에서 서버와 클라이언트를 순차적으로 실행.
- **일회성 메시지 교환**: 클라이언트가 메시지를 전송하면, 서버가 한 번 응답을 보냄.
- **기본적인 소켓 처리**: 연결 설정, 메시지 송수신, 연결 종료 등 소켓 프로그래밍의 기초를 간단히 체험.

## 실행 시나리오
단일 스레드 상에서 다음과 같은 순서로 동작합니다:

1. **SimpleSocketTest 실행**
   - `ServerMock` 객체를 생성하고 `server.start(6666)` 메서드를 통해 서버 소켓을 열어 대기합니다.
   - 약간의 지연(스레드 슬립)을 준 뒤, `ClientMock` 객체를 생성하고 `connectToServer()`를 호출하여 서버에 연결을 시도합니다.
   - 다시 지연 후, 서버가 `handleClient()`를 통해 클라이언트로부터 메시지를 받습니다.
   - 서버는 메시지를 받은 후, 사용자가 콘솔에 직접 입력한 내용을 클라이언트에게 전송합니다.
   - 마지막으로, 클라이언트가 `handleServer()`를 통해 서버 응답을 받습니다.
   - 통신을 마친 뒤, `server.stop()`으로 서버와 클라이언트 소켓이 정리되고 종료됩니다.

즉, **단일 스레드**지만, `Thread.sleep()` 같은 지연을 사용하여 서버가 먼저 준비되도록 순서를 제어합니다.

## 왜 컴파일할 때 `*.java`를 사용하는가?
`javac`를 사용할 때 `*.java`를 지정하면, 해당 디렉터리 내에 있는 모든 Java 파일을 한꺼번에 컴파일합니다. 이 프로젝트는 다음과 같은 세 파일을 모두 컴파일해야 합니다:
- `ClientMock.java`
- `ServerMock.java`
- `SimpleSocketTest.java`

한 번에 컴파일해야 하는 이유:
- 각 파일에서 다른 파일을 참조하고 있기 때문입니다. 예를 들어, `SimpleSocketTest.java`는 `ServerMock`과 `ClientMock`을 사용합니다.
- 자바 컴파일 시점에는 참조되는 클래스가 모두 컴파일되어 있어야 합니다.

스레드와 관련해서, 멀티스레드 환경에서는 여러 파일을 각각 다양한 시점에 컴파일해도 상관없을 수 있지만, 일반적인 상황에서는 의존 관계가 있는 모든 파일을 한 번에 빌드하는 방식이 안정적이고 편리합니다. 이 프로젝트는 단일 스레드로 작성되어 있지만, 자바는 내부적으로 `main` 메서드를 실행하는 스레드가 별도로 존재하며, 우리가 `Thread.sleep()`이나 다른 스레드 관련 기능을 쓰면 동시에 여러 작업을 수행할 수 있습니다.

그러나 여기서는 **직접적으로 스레드를 여러 개 생성하는 것이 아니라** 단일 스레드(`main` 스레드) 안에서 순차적으로 다음 동작을 수행합니다:
1. 서버 소켓 생성 및 대기
2. 클라이언트 소켓 연결
3. 서버가 메시지 수신
4. 서버가 사용자에게서 입력받아 클라이언트에게 메시지 송신
5. 클라이언트가 응답 수신
6. 종료

이 순서를 지키기 위해 `Thread.sleep()`을 적절히 배치하고 있습니다.

## 컴파일 & 실행 방법
### 1. 컴파일
```bash
# simpleSocket 디렉터리가 있는 상위 경로에서 다음 명령을 실행하세요.
javac -d . simpleSocket/*.java
```
- `-d .` : 현재 디렉터리 구조를 유지하면서 .class 파일을 생성.
- `simpleSocket/*.java` : `simpleSocket` 폴더 안에 있는 모든 .java 파일을 컴파일.

### 2. 실행
```bash
java simpleSocket.SimpleSocketTest
```
- 패키지명을 포함하여 실행해야 합니다.
- 실행 후 서버가 먼저 대기하고, 클라이언트가 연결을 시도합니다.

## 실행 시나리오 (단일 스레드 동작 흐름)
이 프로젝트는 단일 스레드로 동작하며, 하나의 스레드가 서버와 클라이언트를 번갈아 가며 실행합니다. 실행되는 순서는 다음과 같습니다:

1. **SimpleSocketTest 실행 (메인 스레드 시작)**
   - `ServerMock` 객체 생성 후 `server.start(6666)` 호출 → 서버 소켓이 열리고 클라이언트의 접속을 대기.

2. **클라이언트 실행 준비**
   - `Thread.sleep(1000)`을 사용하여 서버가 완전히 실행될 시간을 확보.
   - `ClientMock` 객체 생성 후 `connectToServer()` 호출 → 클라이언트 소켓이 서버에 연결.
   - 클라이언트는 메시지를 입력하고 서버로 전송.

3. **서버가 클라이언트 메시지 수신**
   - `server.handleClient()` 호출 → 클라이언트의 메시지를 읽고 콘솔에 출력.
   - 서버는 콘솔 입력을 대기하여 클라이언트에게 보낼 응답을 입력받음.

4. **서버가 클라이언트에게 응답 전송**
   - 서버가 사용자의 입력을 받아 클라이언트에게 전송.
   - 클라이언트는 서버의 응답을 `handleServer()`를 통해 수신 후 콘솔에 출력.

5. **통신 종료 및 정리**
   - `Thread.sleep(4000)`을 통해 충분한 시간이 지나도록 대기.
   - `server.stop()`을 호출하여 서버와 클라이언트의 소켓을 정리하고 프로그램 종료.

즉, 단일 스레드가 서버와 클라이언트의 역할을 번갈아 수행하면서 통신을 완성합니다.



## 결과
### 서버 출력 예시
```
서버가 시작되었습니다. 클라이언트 접근 대기중...
클라이언트 접속 완료
클라이언트로부터 받은 메시지: Hello Server
클라이언트에게 전송할 메시지를 작성하세요.
(사용자 입력)
클라이언트에게 응답 완료
서버 종료됨.
```

### 클라이언트 출력 예시
```
서버에 접속되었습니다.
서버에 전송할 메시지를 작성하세요.
Hello Server
서버로부터 받은 메시지: (서버의 답장)
클라이언트 종료됨.
```

## 참고 및 확장
- 멀티스레드 서버로 확장하려면 `ServerMock`에서 여러 클라이언트를 동시에 처리하도록 스레드를 추가로 생성해야 합니다.
- 더 복잡한 통신(예: 여러 번의 메시지 교환)을 구현하려면 클라이언트와 서버 모두 반복문 등을 사용해 다중 송수신 로직을 작성해야 합니다.
- 이 코드는 예외 처리나 보안(SSL/TLS), 프로토콜 설계 등이 고려되지 않았습니다.



## 추가 실습: 두 개의 터미널에서 실행하기
이번에는 `SimpleSocketTest`를 사용하지 않고, 서버와 클라이언트를 개별적으로 실행하여 서로 다른 스레드에서 동작하도록 실습해볼 수 있습니다.

### 1. 컴파일
먼저, 모든 파일을 컴파일합니다.
```bash
javac -d . simpleSocket/*.java
```

### 2. 서버 실행
하나의 터미널을 열고 서버를 실행합니다.
```bash
java simpleSocket.ServerMock
```
이제 서버는 클라이언트의 연결을 대기하고 있습니다.

### 3. 클라이언트 실행
새로운 터미널을 열고 클라이언트를 실행합니다.
```bash
java simpleSocket.ClientMock
```
클라이언트가 실행되면 메시지를 입력하고 엔터를 누르면 서버로 메시지가 전송됩니다.

### 4. 메시지 교환 확인
- 서버 터미널에서는 클라이언트로부터 메시지를 받게 되고, 사용자가 직접 응답을 입력해야 합니다.
- 클라이언트 터미널에서는 서버로부터의 응답을 받고 출력합니다.

이제 서버와 클라이언트는 각각 독립적인 터미널에서 실행되며, 서로 다른 스레드에서 실행되는 것과 같은 효과를 가집니다.